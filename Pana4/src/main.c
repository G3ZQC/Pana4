/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.0.0   2018-03-24

The MIT License (MIT)
Copyright (c) 2018 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include "stm32f4xx.h"
#include <stm32f4xx_i2c.h>
#include <stdarg.h>
#include <stm32f4xx_adc.h>
#include "stm32f4xx_rcc.h"
#include <stm32f4xx_dma.h>
#include "arm_math.h"
#include <math.h>
#include "arm_const_structs.h"



/* Private macro */
#define IO_Write(pin, value)  GPIO_WriteBit(pin, value)

/* Private variables */
#define TEST_PIN         GPIOD,GPIO_Pin_11
#define BUFFERSIZE 2048				// DMA buffer filled by ADC1 & 2
#define FFT_IQ_LEN BUFFERSIZE/2
#define FALSE 0
#define TRUE 1
#define Display_Scaling_Factor 4
#define SLAVE_ADDRESS 0x60
//#define TEST_DATA
#define HannSlice 0x7fff/(FFT_IQ_LEN - 1)


//__IO uint16_t ADCBuffer[BUFFERSIZE];		// ADC Buffer length
int16_t ADCBuffer[BUFFERSIZE];			// ADC Buffer length

#ifdef TEST_DATA
int16_t TestBuffer[FFT_IQ_LEN];			// ADC Buffer length
#endif /*TEST_DATA*/

int16_t FFT_Buffer[FFT_IQ_LEN];
//int16_t FFT_Buffer_B;
int16_t FFT_Output[FFT_IQ_LEN/2];
int16_t FFT_Display_Buffer[FFT_IQ_LEN/2];

unsigned long IF_Freq = 10715000 * 4;						// IF frequency in Hz

unsigned int FFT_Busy = FALSE;

/* Private function prototypes */
void RCC_Setup();
void GPIO_Setup();
void DMA_Setup(void);
void ADCSetup();
void TIM2_Configuration(void);
void NVIC_Configuration(void);
void DMA2_Stream0_IRQHandler(void);
void InitDisplay();
void SetFreq(unsigned long frequency);
void init_I2C1();
void Si5351a_Write(unsigned int num, ...);
void I2C_start(I2C_TypeDef* I2Cx, uint8_t address, uint8_t direction);
void I2C_write(I2C_TypeDef* I2Cx, uint8_t data);
void I2C_stop(I2C_TypeDef* I2Cx);
void FFTWindowFunctionHann();

#ifdef TEST_DATA
void Test_Data_Generator();
#endif /*TEST_DATA*/


/* Private functions */



/**
 **===========================================================================
 **
 **  Abstract: main program
 **
 **===========================================================================
 */
int main(void)
{

	//				Setup

	//
	RCC_Setup();

	GPIO_Setup();

	//					Setup DMA transfer
	DMA_Setup();

	//					Setup ADC channels
	ADCSetup();

	#ifdef TEST_DATA
	Test_Data_Generator();
	#endif /*TEST_DATA*/

	// 					Configure Timer for ADC sample rate of 200KHz
	TIM2_Configuration();

	// 					Configure interrupt handler
	NVIC_Configuration();

	//					Initialise graphics display
	InitDisplay();
#ifndef TEST_DATA
	//					Initialise I2C
	init_I2C1();

	//					Start programmable oscillator at the correct frequency
	SetFreq(IF_Freq);

#endif /* TEST_DATA */
	// Start software conversion
	ADC_SoftwareStartConv(ADC1);

	//
	//				Loop
	while (1)
	{

	    if (FFT_Busy == (TRUE))
		{
		//					Process input data

		// Implement I/Q correction???

		/* Convert unsigned integer to 1.15 fixed point format, shift data in FFT_Buffer left by 4
		 * and invert the most significant bit*/
		for (int i = 0; i < FFT_IQ_LEN; i++)
		    {
		    FFT_Buffer[i] = FFT_Buffer[i] << 4;
		    //FFT_Buffer[i] = FFT_Buffer[i] + 16;	// Makes cos wave start at zero, but makes no difference
		    FFT_Buffer[i] = FFT_Buffer[i] ^ 0x8000;
		    }

		IO_Write(TEST_PIN, 1);   				// write one to Port D pin 11

		// Implement 'Windowing' Function????
		FFTWindowFunctionHann();

		/* Process the data through the CFFT/CIFFT module */

		arm_cfft_q15(&arm_cfft_sR_q15_len512, FFT_Buffer, 0, 1);

		IO_Write(TEST_PIN, 0);   				// write one to Port D pin 11

		/* Process the data through the Complex Magnitude Module for
		calculating the magnitude at each bin */
		arm_cmplx_mag_q15 (FFT_Buffer, FFT_Output, (FFT_IQ_LEN/2));

		// Implement low-pass filter????

		// Put data in frequency order in display buffer
		for(uint16_t i = 0; i < (FFT_IQ_LEN/4); i++)
		    {
		        FFT_Display_Buffer[(FFT_IQ_LEN/2) - i - 1] = 20 * Display_Scaling_Factor * log10(FFT_Output[i + FFT_IQ_LEN/4]);
		        // take FFT data, do a log10 and multiply it to scale 10dB (fixed)
		        // apply "AGC", vertical "sliding" offset (or brightness for waterfall)
		    }


		    for(uint16_t i = (FFT_IQ_LEN/4); i < (FFT_IQ_LEN/2); i++)
		    {
		        // build right half of spectrum data
			FFT_Display_Buffer[(FFT_IQ_LEN/2) - i - 1] = 20 * Display_Scaling_Factor * log10(FFT_Output[i - FFT_IQ_LEN/4]);
		        // take FFT data, do a log10 and multiply it to scale 10dB (fixed)
		        // apply "AGC", vertical "sliding" offset (or brightness for waterfall)
		    }

		// Scale data take log10 etc????

		//  Update display

		 FFT_Busy = FALSE;
		}

		//
	}

}

/**************************************************************************/

void DMA2_Stream0_IRQHandler(void) // Called at 1 KHz for 200 KHz sample rate
{
  /* Test on DMA Stream Half Transfer interrupt */
  if(DMA_GetITStatus(DMA2_Stream0, DMA_IT_HTIF0))
  {
    /* Clear DMA Stream Half Transfer interrupt pending bit */
    DMA_ClearITPendingBit(DMA2_Stream0, DMA_IT_HTIF0);
    IO_Write(TEST_PIN, 1);   				// write one to Port D pin 11
    if (FFT_Busy == (FALSE))
	{
	// Add code here to process first half of buffer
	/* Copy the data to FFT_Buffer */
#ifdef TEST_DATA
	arm_copy_q15(TestBuffer, FFT_Buffer, FFT_IQ_LEN);
#endif /*TEST_DATA */
#ifndef TEST_DATA
	arm_copy_q15(ADCBuffer, FFT_Buffer, FFT_IQ_LEN);
#endif /*TEST_DATA */

	FFT_Busy = TRUE;					// Set FFT Busy
	IO_Write(TEST_PIN, 0); 				// write zero to Port D pin 11
    // Copy of 1024 halfwords takes ~70uS
	}
  }

  /* Test on DMA Stream Transfer Complete interrupt */
  if(DMA_GetITStatus(DMA2_Stream0, DMA_IT_TCIF0))
  {
    /* Clear DMA Stream Transfer Complete interrupt pending bit */
    DMA_ClearITPendingBit(DMA2_Stream0, DMA_IT_TCIF0);
    //IO_Write(TEST_PIN, 0); 				// write zero to Port D pin 11

    // Add code here to process second half of buffer (pong)
    //arm_copy_q15(ADCBuffer+BUFFERSIZE/2, &FFT_Buffer_B, BUFFERSIZE/2); due to the time it takes to process the data, just throw this away
  }
}
/************************************************************************/

 void RCC_Setup()
{
	/*
	Set up the clocks are needed for the ADC
	*/
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

	/*
	Set up the clocks are needed for the Timer
	*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

	// enable APB1 peripheral clock for I2C1
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);

	// enable clock for SCL and SDA pins
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
}

void GPIO_Setup()
{
	GPIO_InitTypeDef      GPIO_InitStructure;
	GPIO_StructInit(&GPIO_InitStructure);
	/**
	Initialization of the GPIO Pins [OK]
	*/

	/* Analog channel configuration : PC0 & PC1*/
	 /* ADC Channel 10 -> PC0
	    ADC Channel 11 -> PC1
	 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &GPIO_InitStructure);

	/* setup SCL and SDA pins
	 * You can connect I2C1 to two different
	 * pairs of pins:
	 * 1. SCL on PB6 and SDA on PB7
	 * 2. SCL on PB8 and SDA on PB9
	 */

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; 	// we are going to use PB6 and PB7
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;			// set pins to alternate function
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		// set GPIO speed
	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;			// set output to open drain --> the line has to be only pulled low, not driven high
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;			// enable pull up resistors
	GPIO_Init(GPIOB, &GPIO_InitStructure);					// init GPIOB

	// Connect I2C1 pins to AF
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_I2C1);	// SCL
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_I2C1); // SDA

	// Setup test pin - PD11
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;				 	// we are going to use PD11
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;				// set pin to output
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;			// set GPIO speed
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;				// set output to push-pull
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;			// no pull-up resistor
	GPIO_Init(GPIOD, &GPIO_InitStructure);						// init GPIOD
}

#ifdef TEST_DATA
void Test_Data_Generator()
    {

    float Fgen = 70000;
    float Fsamp = 200000;
    float TwoPi = 2 * 3.14159;
    float phase_Inc = 0.0;

    for (int i = 0; i < BUFFERSIZE/2; i++)
	{
    	    TestBuffer[i] = (2047 + (2047 * cos(phase_Inc)));
    	    i = i + 1;
    	    TestBuffer[i] = (2047 + (2047 * sin(phase_Inc)));
    	    phase_Inc += TwoPi * Fgen / Fsamp;

    	    if (phase_Inc > TwoPi)
    		{
    		phase_Inc = phase_Inc - TwoPi;
    		}
    	}
    }
#endif /*TEST_DATA*/

void ADCSetup()
{

	ADC_InitTypeDef       ADC_InitStructure;
	ADC_CommonInitTypeDef ADC_CommonInitStructure;


	ADC_StructInit(&ADC_InitStructure);
	ADC_CommonStructInit(&ADC_CommonInitStructure);



	/**
	Config ADC1 & 2
	*/
	ADC_DeInit();

	ADC_CommonInitStructure.ADC_Mode = ADC_DualMode_RegSimult;
	ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;		//was 5
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_1;
	ADC_CommonInit(&ADC_CommonInitStructure);

	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; // Conversions triggered
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_Rising;
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_TRGO;
	ADC_InitStructure.ADC_NbrOfConversion = 1;
	ADC_InitStructure.ADC_ScanConvMode = DISABLE; // One channel in group
	ADC_Init(ADC1,&ADC_InitStructure);
	ADC_Init(ADC2,&ADC_InitStructure);



	ADC_RegularChannelConfig(ADC1,ADC_Channel_10,1,ADC_SampleTime_15Cycles);
	ADC_RegularChannelConfig(ADC2,ADC_Channel_11,1,ADC_SampleTime_15Cycles);

	/* Enable DMA request after last transfer (Multi-ADC mode)  */
	ADC_MultiModeDMARequestAfterLastTransferCmd(ENABLE);

	ADC_Cmd(ADC1, ENABLE);   // Enable ADC1

	ADC_Cmd(ADC2, ENABLE);   // Enable ADC2

	//ADC_SoftwareStartConv(ADC1); // Start ADC1 conversion

}

/*****************************************************************************/

void DMA_Setup(void)
{
	DMA_InitTypeDef       DMA_InitStructure;

	DMA_StructInit(&DMA_InitStructure);

	/**
		Configure the DMA
		*/
	DMA_InitStructure.DMA_Channel = DMA_Channel_0;
	DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADCBuffer;
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)0x40012308;
	// CDR_ADDRESS; Packed ADC1, ADC2
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
	DMA_InitStructure.DMA_BufferSize = BUFFERSIZE; // Count of 16-bit words
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
	DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
	DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
	DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
	DMA_Init(DMA2_Stream0, &DMA_InitStructure);

	/* Enable DMA Stream Half / Transfer Complete interrupt */
	DMA_ITConfig(DMA2_Stream0, DMA_IT_TC | DMA_IT_HT, ENABLE);

	/* DMA2_Stream0 enable */
	DMA_Cmd(DMA2_Stream0, ENABLE);

}


/*****************************************************************************/

void TIM2_Configuration(void)
{
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

  /* Time base configuration */
  TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);

  //TIM_TimeBaseStructure.TIM_Period = 250;
  TIM_TimeBaseStructure.TIM_Period = (84000000 / 200000) - 1;
  // 200 KHz, from 84 MHz TIM2CLK (ie APB1 = HCLK/4, TIM2CLK = HCLK/2)
  TIM_TimeBaseStructure.TIM_Prescaler = 0;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

  /* TIM2 TRGO selection */
  TIM_SelectOutputTrigger(TIM2, TIM_TRGOSource_Update);
  // ADC_ExternalTrigConv_T2_TRGO

  /* TIM2 enable counter */
  TIM_Cmd(TIM2, ENABLE);
}

/**********************************************************************/

void NVIC_Configuration(void)
{
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the DMA Stream IRQ Channel */
  NVIC_InitStructure.NVIC_IRQChannel = DMA2_Stream0_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
}


/**********************************************************************/

void InitDisplay()
{
}

void SetFreq(unsigned long frequency)
{
	//#define F_XTAL 27005701;             // Frequency of Quartz-Oscillator
	#define F_XTAL 25000000;             // Frequency of Quartz-Oscillator
	#define c 1048574;                   // "c" part of Feedback-Multiplier from XTAL to PLL
	unsigned long fvco;                  // VCO frequency (600-900 MHz) of PLL
	unsigned long outdivider; // Output divider in range [4,6,8-900], even numbers preferred
	int R = 1;              // Additional Output Divider in range [1,2,4,...128]
	int a;  // "a" part of Feedback-Multiplier from XTAL to PLL in range [15,90]
	unsigned long b;         // "b" part of Feedback-Multiplier from XTAL to PLL
	float f;                         // floating variable, needed in calculation
	unsigned long MS0_P1; // Si5351a Output Divider register MS0_P1, P2 and P3 are hardcoded below
	unsigned long MSNA_P1;       // Si5351a Feedback Multisynth register MSNA_P1
	unsigned long MSNA_P2;       // Si5351a Feedback Multisynth register MSNA_P2
	unsigned long MSNA_P3;       // Si5351a Feedback Multisynth register MSNA_P3

	outdivider = 900000000 / frequency; // With 900 MHz being the maximum internal PLL-Frequency

	while (outdivider > 900)

	{ // If output divider out of range (>900) use additional Output divider
		R = R * 2;
		outdivider = outdivider / 2;
	}
	if (outdivider % 2)
		outdivider--; // finds the even divider which delivers the intended Frequency

	fvco = outdivider * R * frequency; // Calculate the PLL-Frequency (given the even divider)

	switch (R)
	{ // Convert the Output Divider to the bit-setting required in register 44
	case 1:
		R = 0;
		break;              // Bits [6:4] = 000
	case 2:
		R = 16;
		break;             // Bits [6:4] = 001
	case 4:
		R = 32;
		break;             // Bits [6:4] = 010
	case 8:
		R = 48;
		break;             // Bits [6:4] = 011
	case 16:
		R = 64;
		break;            // Bits [6:4] = 100
	case 32:
		R = 80;
		break;            // Bits [6:4] = 101
	case 64:
		R = 96;
		break;            // Bits [6:4] = 110
	case 128:
		R = 112;
		break;          // Bits [6:4] = 111
	}

	a = fvco / F_XTAL
	;             // Multiplier to get from Quartz-Oscillator Freq. to PLL-Freq.
	f = fvco - a * F_XTAL
	;               // Multiplier = a+b/c
	f = f * c
	;                           // this is just "int" and "float" mathematics
	f = f / F_XTAL
	;
	b = f;

	MS0_P1 = 128 * outdivider - 512; // Calculation of Output Divider registers MS0_P1 to MS0_P3
									 // MS0_P2 = 0 and MS0_P3 = 1; these values are hardcoded, see below

	f = 128 * b / c
	;         // Calculation of Feedback Multisynth registers MSNA_P1 to MSNA_P3
	MSNA_P1 = 128 * a + f - 512;
	MSNA_P2 = f;
	MSNA_P2 = 128 * b - MSNA_P2 * c
	;
	MSNA_P3 = c
	;

	Si5351a_Write(3, 16, 128, 128); // Disable output during the following register settings

	Si5351a_Write(9, 26, (MSNA_P3 & 65280) >> 8, MSNA_P3 & 255,
			(MSNA_P1 & 196608) >> 16, (MSNA_P1 & 65280) >> 8, MSNA_P1 & 255,
			((MSNA_P3 & 983040) >> 12) | ((MSNA_P2 & 983040) >> 16),
			(MSNA_P2 & 65280) >> 8, MSNA_P2 & 255); // Bits [15:8] of MSNA_P3 in register 26


	Si5351a_Write(9, 42, 0, 1, ((MS0_P1 & 196608) >> 16) | R,
			(MS0_P1 & 65280) >> 8, MS0_P1 & 255, 0, 0, 0); // Bits [15:8] of MS0_P3 (always 0) in register 42

	if (outdivider == 4)
	{
		Si5351a_Write(4, 44, 12 | R, 0, 0); // Special settings for R = 4 (see datasheet)

	}
	Si5351a_Write(9, 50, 0, 1, ((MS0_P1 & 196608) >> 16) | R,
			(MS0_P1 & 65280) >> 8, MS0_P1 & 255, 0, 0, 0); // Bits [15:8] of MS0_P3 (always 0) in register 42


	if (outdivider == 4)
	{
		Si5351a_Write(4, 52, 12 | R, 0, 0); // Special settings for R = 4 (see datasheet)

	}
	Si5351a_Write(3, 165, 0, outdivider);                   // Sets phase offset

	Si5351a_Write(2, 177, 32);                      		// This resets PLL A

	Si5351a_Write(3, 16, 13, 13); 							// Enable output during the following register settings, PLLA to multisync

}
void Si5351a_Write(unsigned int num, ...)

{   // Writes parameters into Si5351a via I2C

	I2C_start(I2C1, SLAVE_ADDRESS << 1, I2C_Direction_Transmitter); // start a transmission in Master transmitter mode
	va_list args;
	va_start(args, num);
	int i;
	for (i = 0; i < num; ++i)
	{
		I2C_write(I2C1, va_arg(args, int));
	}
	va_end(args);

	I2C_stop(I2C1); 									// stop the transmission
}

void init_I2C1(void) {

	//GPIO_InitTypeDef GPIO_InitStruct;

	I2C_InitTypeDef I2C_InitStruct;

	// enable APB1 peripheral clock for I2C1
	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);

	// enable clock for SCL and SDA pins
	//RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);



	// configure I2C1
	I2C_InitStruct.I2C_ClockSpeed = 400000; 		// 400kHz
	I2C_InitStruct.I2C_Mode = I2C_Mode_I2C;			// I2C mode
	I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;	// 50% duty cycle --> standard
	I2C_InitStruct.I2C_OwnAddress1 = 0x00;// own address, not relevant in master mode
	I2C_InitStruct.I2C_Ack = I2C_Ack_Disable;// disable acknowledge when reading (can be changed later on)
	I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; // set address length to 7 bit addresses
	I2C_Init(I2C1, &I2C_InitStruct);				// init I2C1

	// enable I2C1
	I2C_Cmd(I2C1, ENABLE);
}

void I2C_start(I2C_TypeDef* I2Cx, uint8_t address, uint8_t direction) {

	// wait until I2C1 is not busy anymore

	while (I2C_GetFlagStatus(I2Cx, I2C_FLAG_BUSY))
		;

	// Send I2C1 START condition
	I2C_GenerateSTART(I2Cx, ENABLE);

	// wait for I2C1 EV5 --> Slave has acknowledged start condition
	while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
		;

	// Send slave Address for write
	I2C_Send7bitAddress(I2Cx, address, direction);

	/* wait for I2C1 EV6, check if
	 * either Slave has acknowledged Master transmitter or
	 * Master receiver mode, depending on the transmission
	 * direction
	 */

	if (direction == I2C_Direction_Transmitter) {
		while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
			;
	}

	else if (direction == I2C_Direction_Receiver) {
		while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
			;
	}
}

/* This function transmits one byte to the slave device
 * Parameters:
 *		I2Cx --> the I2C peripheral e.g. I2C1
 *		data --> the data byte to be transmitted
 */

void I2C_write(I2C_TypeDef* I2Cx, uint8_t data)
{
	I2C_SendData(I2Cx, data);
	// wait for I2C1 EV8_2 --> byte has been transmitted
	while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
		;
}

/* This function issues a stop condition and therefore

 * releases the bus

 */

void I2C_stop(I2C_TypeDef* I2Cx)
{

	// Send I2C1 STOP Condition

	I2C_GenerateSTOP(I2Cx, ENABLE);

}

void FFTWindowFunctionHann()
    {
    int16_t sect = 0;
    int16_t temp;
    for(int i = 0; i < FFT_IQ_LEN; i++)
            {
                //FFT_Buffer[i] = 0.5 * (int16_t)((1 - (arm_cos_q15(PI*2 * (int16_t)i / (int16_t)(FFT_IQ_LEN-1)))) * FFT_Buffer[i]);
                //FFT_Buffer[i] =  (int16_t)((int32_t)((0x7ffe - (arm_cos_q15((int16_t) sect))) * 0x7f00) >> (15));
		    temp = (int16_t)(arm_cos_q15((int16_t) sect));
		   //temp = temp >>(1);
		    if (temp & 0x8000)
			{
			temp = - temp;
			temp = temp >> (1);
			temp = temp & 0x7fff;
			temp = - temp;
			}
		    else
			{
			temp = temp >> (1);
			temp = temp & 0x7fff;
			}
		    temp = 0x3fff - temp;
	          FFT_Buffer[i] = (temp * FFT_Buffer[i]) >> (15);
	          sect += HannSlice;
            }
    }
